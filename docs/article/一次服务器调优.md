## 记一次服务器调优

> 背景：在服务上线前夕，对我负责的一个查询接口进行压力测试，测试时发现，服务器的 cpu 占用率 很高， 4c16g 的机器，cpu 占用率达到 70%，这个查询接口是对第三方的 webservice 协议接口进行封装的。webservice接口部分使用的是生成的客户端代理类。


为了找到为什么在压测期间 cpu 占用率飙升，我在测试期间上服务器 dump 线程堆栈信息。使用的是 jdk 自带的 jstack 工具

使用方法是：`jstack -l pid > stack.txt` 将终端打印的堆栈信息重定向到 stack.txt 文本中，方便后续分析。

将堆栈信息文本上传到 [fastThread](https://fastthread.io/) 网站进行分析。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9dr46kk6jj323a0u0aes.jpg)

从分析结果发现 `java.util.zip.ZipFile $ ZipFileInputStream.read` 方法被大量调用，此方法是 jdk 中的方法，我也没有手动调用过，查看该该部分源码发现该该方法还加了同步锁。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9dr9mworrj31ta0egab6.jpg)

因此，必须找到为何会频繁调用此方法，在本地 debug 发现，在调用webservice 接口前，要创建代理对象，创建代理对象的过程中会调用这个方法，而且没请求一次，就会重新创建一个代理对象。至此找到了 cpu 占用率飙升的原因。

解决方案：

使用单例模式创建代理对象，使得代理对象只需要创建一次。


![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9drklulcjj31qg0p4adg.jpg)


验证：修改代码后，重新进行压测。发现 cpu 占用率维持在30%左右，并对压测时的线程堆栈信息进行分析。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9ds60jt9aj32cy0u0781.jpg)


+ [参考资料1](https://blog.csdn.net/u013630349/article/details/99886088)
+ [参考资料2](https://blog.csdn.net/Ki8Qzvka6Gz4n450m/article/details/93377331)
+ [jstat命令使用](https://www.cnblogs.com/yjd_hycf_space/p/7755633.html)
+ [jstat命令官方文档](https://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html)



### 记一次 JAVA StackOverFlowError 异常

> 背景：昨天同事的一段程序出现了StackOverFlowError 异常，问我怎么处理，我看了下代码，在这段代码里有递归，递归写的正确，有出口，但是递归的层级一点深，一共有2600级，递归到 2200 左右是抛出 StackOverFlowError 异常

我分析了一下，出现该异常是由于递归的调用是这个一个线程中的，JVM 默认给一个线程分配的内存空间是 1M 大小，加上由于递归调用比较深，压栈比较多，导致分配给线程的内存空间耗尽，出现 StackOverFlowError 异常。

对此我给出 3 个解决方案

1、不使用递归

2、使用多线程的并发递归

3、设置 JVM 启动参数 -Xss2M 将分配给线程的默认内存空间调大

`java -Xss2M -jar test.jar`

+ [参考资料1](http://club.oneapm.com/t/stackoverflowerror/1295)
+ [参考资料2](https://www.cnblogs.com/ceshi2016/p/8447989.html)

