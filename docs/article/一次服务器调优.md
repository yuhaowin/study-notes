## 记一次服务器调优

> 背景：在服务上线前夕，对我负责的一个查询接口进行压力测试，测试时发现，服务器的 cpu 占用率 很高， 4c16g 的机器，cpu 占用率达到 70%，这个查询接口是对第三方的 webservice 协议接口进行封装的。webservice接口部分使用的是生成的客户端代理类。


为了找到为什么在压测期间 cpu 占用率飙升，我在测试期间上服务器 dump 线程堆栈信息。使用的是 jdk 自带的 jstack 工具

使用方法是：`jstack -l pid > stack.txt` 将终端打印的堆栈信息重定向到 stack.txt 文本中，方便后续分析。

将堆栈信息文本上传到 [fastThread](https://fastthread.io/) 网站进行分析。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9dr46kk6jj323a0u0aes.jpg)

从分析结果发现 `java.util.zip.ZipFile $ ZipFileInputStream.read` 方法被大量调用，此方法是 jdk 中的方法，我也没有手动调用过，查看该该部分源码发现该该方法还加了同步锁。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9dr9mworrj31ta0egab6.jpg)

因此，必须找到为何会频繁调用此方法，在本地 debug 发现，在调用webservice 接口前，要创建代理对象，创建代理对象的过程中会调用这个方法，而且没请求一次，就会重新创建一个代理对象。至此找到了 cpu 占用率飙升的原因。

解决方案：

使用单例模式创建代理对象，使得代理对象只需要创建一次。


![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9drklulcjj31qg0p4adg.jpg)


验证：修改代码后，重新进行压测。发现 cpu 占用率维持在30%左右，并对压测时的线程堆栈信息进行分析。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9ds60jt9aj32cy0u0781.jpg)


+ [参考资料1](https://blog.csdn.net/u013630349/article/details/99886088)
+ [参考资料2](https://blog.csdn.net/Ki8Qzvka6Gz4n450m/article/details/93377331)
+ [jstat命令使用](https://www.cnblogs.com/yjd_hycf_space/p/7755633.html)
+ [jstat命令官方文档](https://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html)